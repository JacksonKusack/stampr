---
title: "stampr analysis"
author: "Colin Robertson"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Introduction to analysis of moving polygons in space-time using the `stampr` package.

```{r}
library(stampr)
library(sp)
library(igraph)
data('katrina')
class(katrina)
head(katrina@data)
```

## Simple two-time period change detection using overlay

```{r tidy=TRUE}
T1 <- katrina[1,]
T2 <- katrina[2,]
T1$ID <- T1$Id
T2$ID <- T2$Id
plot(T1, col=NA, border="green", lwd=2, xlim=c(min(c(bbox(T1)[1,1], bbox(T2)[1,1])), max(c(bbox(T1)[1,2], bbox(T2)[1,2]))), ylim=c(min(c(bbox(T1)[2,1], bbox(T2)[2,1])), max(c(bbox(T1)[2,2], bbox(T2)[2,2]))))
plot(T2, col=NA, border="red", add=TRUE, lwd=2)
```

The change we want to detect is the proportion of overlap, green only, and red only areas, representing stability, contraction and expansion events respectively.

```{r tidy=TRUE}
ch <- stamp(T1, T2, dc=0, direction=TRUE, distance=TRUE)
stamp.map(ch)
head(ch@data)
```

## Multiple time period polygon change analysis using overlay
```{r tidy=TRUE}
T3 <- katrina[3,]
T3$ID <- T3$Id
ch2 <- stamp(T2, T3, dc=0, direction=TRUE, distance=TRUE)
head(ch2@data)
```

## Multiple time period polygon change analysis using overlay
Here is a brute force way to run the `stamp` function over multiple time periods using a loop;
```{r tidy=TRUE}
outEvents <- list()
lSum <- 1
katrina$ID <- katrina$Id
for(i in 1:(nrow(katrina@data)-1)) {
  Ti <- katrina[i,]
  Ti_1 <- katrina[i+1,]
  ch <- stamp(Ti, Ti_1, dc=0, direction=TRUE, distance=TRUE)
  xx1 <- spChFIDs(ch, paste(i, "-", as.character((lSum):(lSum+length(ch)-1)), sep=""))
  lSum <- length(ch) + lSum
  outEvents[[i]] <- xx1 #@data
} 

outEvents <- do.call("rbind", outEvents)
```

## Get summaries from multiple change events
```{r tidy=TRUE}
grps <- row.names(outEvents) #get row names
outEvents$TGROUP <- substr(grps, 1, as.numeric(unlist(lapply(strsplit(grps, ''), function(x) which(x == '-'))))-1) #extract time period to distinguish change time periods
outEvents$STGROUP <- as.numeric(paste(outEvents$TGROUP,outEvents$GROUP, sep="")) #generate group ID for specific time periods
outSTGroup <- stamp.stgroup.summary(outEvents)
head(outSTGroup)
```

##Do some more graphing of the topological relationships
```{r tidy=TRUE}
df <- data.frame(from=outEvents$ID1,to=outEvents$ID2, stg = outEvents$STGROUP)
df <- df[complete.cases(df),]
df <- merge(outSTGroup, df, by.x="STGROUP", by.y="stg")
df$weight <- (df$aSTBL / df$AREA) * 10
df <- data.frame(from=df$from,to=df$to, weight = df$weight)
g <- graph_from_data_frame(df, directed = TRUE, vertices=df$ID1)
E(g)$weight <- df$weight 
plot(g, edge.width=E(g)$weight, layout=layout.fruchterman.reingold, edge.curved=TRUE, vertex.size=5, edge.arrow.mode='-')
```

Lets look at T=1:10, and T=11:20, and T=21:32 separately to see if we can see any changes in space-time structure...
```{r tidy=TRUE}
df2 <- df[1:10,]
g <- graph_from_data_frame(df2, directed = TRUE, vertices=df2$ID1)
E(g)$weight <- df2$weight
plot(g, edge.width=E(g)$weight, layout=layout.fruchterman.reingold, edge.curved=TRUE, vertex.size=5, edge.arrow.mode='-')
df2 <- df[11:20,]
g <- graph_from_data_frame(df2, directed = TRUE, vertices=df2$ID1)
E(g)$weight <- df2$weight
plot(g, edge.width=E(g)$weight, layout=layout.fruchterman.reingold, edge.curved=TRUE, vertex.size=5, edge.arrow.mode='-')
df2 <- df[21:32,]
g <- graph_from_data_frame(df2, directed = TRUE, vertices=df2$ID1)
E(g)$weight <- df2$weight
plot(g, edge.width=E(g)$weight, layout=layout.fruchterman.reingold, edge.curved=TRUE, vertex.size=5, edge.arrow.mode='-')

```

##Space-time Graph Clustering
```{r}
data('mpb')
mpb$ID <- 1:nrow(mpb)
T1 <- subset(mpb, as.numeric(TGROUP)==1)
T2 <- subset(mpb, as.numeric(TGROUP)==2)
ch <- stamp(T1, T2, dc=2500, direction=TRUE, distance=TRUE)

```

Lets try it out, getting multiple change events for katrina data when each row is a polygon at a separate time period

```{r}
rm(list=ls()) #need to rerun code above to create function after this
data("katrina")
katrina$ID <- katrina$Id
chng <- stamp.multichange(katrina, changeByRow = TRUE, stampArgs = list(0, TRUE, TRUE))
outSTGroup <- stamp.stgroup.summary(chng)
head(outSTGroup)
```

Now lets try the `stamp.multichange` function on the `mpb` data and a sumary function `stamp.stgroup.summary` :
```{r}
data("mpb")
mpb$ID <- nrow(mpb)
chng <- stamp.multichange(mpb, changeByRow = FALSE, changeByField=TRUE, changeField = "TGROUP", stampArgs = list(2000, TRUE, TRUE))
outSTGroup <- stamp.stgroup.summary(chng)
head(outSTGroup)
```

Lets try our previous s-t topology graphing with the more complex `mpb` dataset
```{r}
df <- data.frame(from=chng$ID1,to=chng$ID2, stg = chng$STGROUP, tg=chng$TGROUP)
df <- df[complete.cases(df),]
df <- merge(outSTGroup, df, by.x="STGROUP", by.y="stg")
df$weight <- (df$aSTBL / df$AREA) * 10
df <- data.frame(from=df$from,to=df$to, weight = df$weight, tg = df$tg)
fromIDs <- data.frame(names=as.character(unique(df$from)))
toIDs <- data.frame(names=as.character(unique(df$to)))
vertNames <- rbind(fromIDs, toIDs)

g <- graph_from_data_frame(df, directed = TRUE, vertices=unique(vertNames))

E(g)$weight <- df$weight 
#replace with function
v_layers_df <- unique( rbind(
  expand.grid( ID = df$from[df$tg==1], Layer = 1),
  expand.grid( ID = df$to[df$tg==1], Layer = 2),
  expand.grid( ID = df$from[df$tg==2], Layer = 2),
  expand.grid( ID = df$to[df$tg==2], Layer = 3),
  expand.grid( ID = df$from[df$tg==3], Layer = 3),
  expand.grid( ID = df$to[df$tg==3], Layer = 4),
  expand.grid( ID = df$from[df$tg==4], Layer = 4),
  expand.grid( ID = df$to[df$tg==4], Layer = 5),
  expand.grid( ID = df$from[df$tg==5], Layer = 5),
  expand.grid( ID = df$to[df$tg==5], Layer = 6),
  expand.grid( ID = df$from[df$tg==6], Layer = 6),
  expand.grid( ID = df$to[df$tg==6], Layer = 7),
  expand.grid( ID = df$from[df$tg==7], Layer = 7),
  expand.grid( ID = df$to[df$tg==7], Layer = 8)
  ))

v_layers <- setNames( v_layers_df$Layer, v_layers_df$ID)
V(g)$layer <- v_layers[V(g)$name]


layout.k_partite <- function(g) {
  l <- layout.sugiyama(g)$layout[,2:1]
  l[,1] <- V(g)$layer
  l[,2] <- - l[,2] + 1 + max(l[,2])
  l
}

plot(g, layout = layout.k_partite(g), vertex.label=NA)
plot(g)
```

